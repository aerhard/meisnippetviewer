

  var Logger = {

    /**
     * @property {Boolean} enabled specifies if logging is enabled or disabled.
     * Defaults to false.
     * @private
     */
    enabled : false,

    /**
     * @method setEnabled enables or disables MEI2VF logging
     * @param {Boolean} value
     */
    setEnabled : function (value) {
      this.enabled = value;
    },

    /**
     * @method log Passes the function arguments to VexFlow's log method Vex.L
     * if {@link #enabled} is `true`
     * @private
     */
    log : function () {
      if (this.enabled) {
        Vex.L("MEISnippetViewer", arguments);
      }
    }

  };



  /**
   * @class MSV.Document
   * @singleton
   */
  var Document = {

    /**
     * initializes an xml document; if a string is passed, it gets parsed
     *
     * @param {String|XMLDocument} xmlDoc the input string / input XML document
     * object. If you pass a document object, be sure that it is an XMLDocument, not
     * an HTMLDocument.
     * @return {XMLDocument} the xml document to be rendered
     */
    initXmlDoc : function (xmlDoc) {
      return (typeof xmlDoc === 'string') ? this.parseXML(xmlDoc) : (xmlDoc[0] || xmlDoc);
    },

    parseXML : function (str) {
      var xmlDoc, parser;
      if (window.DOMParser) {
        parser = new DOMParser();
        xmlDoc = parser.parseFromString(str, "text/xml");
      } else // Internet Explorer
      {
        xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async = false;
        xmlDoc.loadXML(str);
      }
      return xmlDoc;
    },

    /**
     * checks if descendants of the provided element have xml:ids; adds xml:ids
     * if they are missing
     * @param {Element} element
     */
    ascertainDescendantIds : function (element, prefix) {
      var i, items = element.getElementsByTagName("*");
      for (i = items.length; i--;) {
        if (!items[i].hasAttribute('xml:id')) {
          items[i].setAttribute('xml:id', prefix + i);
        }
      }
    },

    /**
     * Gets the MEI page config from a scoreDef element.
     * @param {Element} scoreDef The scoreDef element.
     * @return {Object} the config object
     */
    getMEIPageConfig : function (scoreDef) {
      var obj = m2v.Util.attsToObj(scoreDef);
      var convert = function (input) {
        return (isNaN(input) || input.length === 0) ? undefined : +input;
      };
      return {
        page_scale : parseInt(obj['page.scale'], 10) / 100 || undefined,
        page_height : convert(obj['page.height']),
        page_width : convert(obj['page.width']),
        page_margin_top : convert(obj['page.topmar']),
        page_margin_left : convert(obj['page.leftmar']),
        page_margin_right : convert(obj['page.rightmar'])
      };
    }
  };


  /**
   * @class MSV.RuntimeError
   * @private
   *
   * @constructor
   * @param {String} error_code
   * @param {String} message
   */
  var RuntimeError = function (error_code, message) {
    this.error_code = error_code;
    this.message = message;
  };

  /**
   * @method
   * @return {String} the string representation of the error
   */
  RuntimeError.prototype.toString = function () {
    return 'MSV.RuntimeError, code "' + this.error_code + '": ' + this.message;
  };


  /**
   * @class MSV.UI
   */
  var UI = function () {
    this.init();
  };

  UI.prototype = {

    init : function () {
      var me = this;
      me.mouseClickHandlers = [];
      me.mouseMoveHandlers = [];
      me.vexLayerIndex = null;
    },

    createLayers : function (cfg) {
      var me = this, h, w, canvases = '', element, ctx, i, j, div, layers, hasVexLayer = false, canvasTemplate;

      me.scale = cfg.page_scale;

      // unwrap target if it's a jQuery object
      var target = cfg.target[0] || cfg.target;

      layers = cfg.layers;
      h = cfg.page_height * cfg.page_scale;
      w = cfg.page_width * cfg.page_scale;
      j = layers.length;

      // TODO das evtl noch anders l√∂sen
      while (j--) {
        if (layers[j].type === 'vex') hasVexLayer = true;
      }

      // add VexFlow layer if no VexFlow layer has been specified
      if (!hasVexLayer) {
        Logger.log('UI.createLayers()', 'No VexFlow layer specified. Adding it.');
        layers.push({
          type : 'vex'
        });
      }

      var div = me.createOuterDiv(w);
      div.appendChild(innerDiv = me.createInnerDiv(w, h));

      for (var i = 0, j = layers.length; i < j; i++) {
        element = me.createCanvas(w, h);
        innerDiv.appendChild(element);

        if (layers[i].type === 'vex') {
          me.vexLayerIndex = i;
          ctx = me.createVexContext(element, cfg.backend);
          layers[i].element = element;
          layers[i].ctx = ctx;
        } else if (layers[i].type === 'highlighter') {
          ctx = element.getContext('2d');
          layers[i].setElement(element);
          layers[i].setContext(ctx);
          layers[i].setScale(cfg.page_scale);
        } else {
          throw new RuntimeError('Configuration Error', 'Layer type "' + layers[i].type + '" not valid.');
        }
        me.scaleContext(ctx, cfg);
      }

      target.appendChild(div);

      /**
       * @property {Object} topCanvas the top canvas containing the regular
       * MEI2VF output to which the mouse listeners get added.
       */
      me.topCanvas = layers[layers.length - 1].element;
      return layers;
    },

    /**
     * Creates a single canvas element
     * @param w
     * @param h
     * @returns {HTMLElement}
     */
    createCanvas : function (w, h) {
      var canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      canvas.style.position = 'absolute';
      canvas.style.background = 'transparent';
      return canvas;
    },

    /**
     * Creates the outer div wrapper for the canvases
     * @param w
     * @returns {HTMLElement}
     */
    createOuterDiv : function (w) {
      var div = document.createElement('div');
      div.className = "outer-container";
      div.style.marginLeft = (w / 2) + 'px';
      div.style.marginRight = (w / 2) + 'px';
      return div;
    },

    /**
     * Creates the inner div wrapper for the canvases
     * @param w
     * @param h
     * @returns {HTMLElement}
     */
    createInnerDiv : function (w, h) {
      var innerDiv = document.createElement('div');
      innerDiv.className = "inner-container";
      innerDiv.style.position = "relative";
      innerDiv.style.width = "100%";
      innerDiv.style.margin = "auto";
      innerDiv.style.height = h + 'px';
      innerDiv.style.left = (-w / 2) + 'px';
      return innerDiv;
    },

    createVexContext : function (canvas, backend) {
      return new VF.Renderer(canvas, backend || VF.Renderer.Backends.CANVAS).getContext();
    },

    scaleContext : function (ctx, cfg) {
      var me = this, paper, w, h;
      if (+cfg.backend === VF.Renderer.Backends.RAPHAEL) {
        paper = ctx.paper;
        h = cfg.page_height;
        w = cfg.page_width;
        paper.setSize(w * scale, h * scale);
        paper.setViewBox(0, 0, w, h);
      } else {
        ctx.scale(me.scale, me.scale);
      }
    },

    registerMouseClickHandler : function (handler) {
      var me = this;
      me.mouseClickHandlers.push(handler);
    },

    registerMouseMoveHandler : function (handler) {
      var me = this;
      me.mouseMoveHandlers.push(handler);
    },

    listenMouseClick : function () {
      var me = this;
      $(me.topCanvas).on('click', function (e) {
        var offset, mousePos, i;
        offset = $(this).offset();
        mousePos = {
          x : (e.pageX - offset.left) / me.scale,
          y : (e.pageY - offset.top) / me.scale
        };
        i = me.mouseClickHandlers.length;
        while (i--) {
          // if onClick returns false, events will not bubble up to the following layers
          if (me.mouseClickHandlers[i].onClick(mousePos, me.topCanvas, e) === false) {
            return;
          }
        }
      });
    },

    listenMouseMove : function () {
      var me = this;
      me.topCanvas.onmouseleave = function (e) {
        var i = me.mouseMoveHandlers.length;
        while (i--) {
          me.mouseMoveHandlers[i].removeHighlight();
          if (me.mouseMoveHandlers[i].mouseLeaveHandler) {
            me.mouseMoveHandlers[i].mouseLeaveHandler(null, me.topCanvas, e);
          }
        }
      };

      me.topCanvas.addEventListener('mousemove', function (e) {
        var offset, mousePos, i;
        offset = $(this).offset();
        mousePos = {
          x : (e.pageX - offset.left) / me.scale,
          y : (e.pageY - offset.top) / me.scale
        };
        i = me.mouseMoveHandlers.length;
        while (i--) {
          // if onMouseMove returns false, events will not bubble up to the following layers
          if (me.mouseMoveHandlers[i].onMouseMove(mousePos, me.topCanvas, e) === false) {
            return;
          }
        }
      });
    }

  };


  /**
   * @class MSV.AreaHelper
   */
  var AreaHelper = function (viewer) {
    this.viewer = viewer;
  };

  AreaHelper.prototype = {

    setAreas : function (meiDoc, layers) {
      var me = this, i, j, k, areas, areaCollection;

      me.measureAreas = [];
      //      me.layerAreas = [];
      me.barlineAreas = [];
      me.measureModifierAreas = [];
      me.noteAreas = [];
      me.variantAreas = [];
      me.anchoredTextAreas = [];
      me.pgHeadAreas = [];

      var hTypes = {
        measures : [],
        //        layers:[],
        variants : [],
        notes : [],
        barlines : [],
        measure_modifiers : [],
        anchoredTexts : [],
        pgHead : []
      };

      var hType

      i = layers.length;
      while (i--) {
        areaCollection = layers[i];
        if (areaCollection.type === 'highlighter') {
          j = areaCollection.content.length;
          while (j--) {
            hType = hTypes[areaCollection.content[j]];
            if (hType) {
              hType.push(areaCollection);
            } else {
              throw new RuntimeError('Configuration Error', 'Area type "' + areaCollection.content[j] +
                                                            '" is not supported');
            }
          }
        }
      }

      i = hTypes['measures'].length;
      j = hTypes['barlines'].length;
      k = hTypes['measure_modifiers'].length;
      if (i > 0 || j > 0 || k > 0) {
        me.calculateMeasureAreas(me.viewer.allVexMeasureStaffs);
        while (i--) {
          hTypes['measures'][i].addAreas(me.measureAreas);
        }
        while (j--) {
          hTypes['barlines'][j].addAreas(me.barlineAreas);
        }
        while (k--) {
          hTypes['measure_modifiers'][k].addAreas(me.measureModifierAreas);
        }
      }

      //      i = hTypes['layers'].length;
      //      if (i > 0) {
      //        me.calculateLayerAreas(XXX);
      //        while (i--) {
      //          hTypes['layers'][i].addAreas(me.layerAreas);
      //        }
      //      }

      i = hTypes['notes'].length;
      if (i > 0) {
        me.calculateNoteAreas(me.viewer.converter.getNotes());
        while (i--) {
          hTypes['notes'][i].addAreas(me.noteAreas);
        }
      }

      i = hTypes['anchoredTexts'].length;
      if (i > 0) {
        me.calculateAnchoredTextAreas(me.viewer.anchoredTexts.getAll());
        while (i--) {
          hTypes['anchoredTexts'][i].addAreas(me.anchoredTextAreas);
        }
      }

      i = hTypes['pgHead'].length;
      if (i > 0 && me.viewer.pgHead) {
        me.calculatePgHeadAreas(me.viewer.pgHead.getTextsByLine());
        while (i--) {
          hTypes['pgHead'][i].addAreas(me.pgHeadAreas);
        }
      }

      i = hTypes['variants'].length;
      if (i > 0) {
        me.getVariantCoordinates(meiDoc);
        while (i--) {
          hTypes['variants'][i].addAreas(me.variantAreas);
        }
      }

      i = layers.length;
      while (i--) {
        if (layers[i].type === 'highlighter') {
          layers[i].initHighlights();
        }
      }

    },

    calculateMeasureAreas : function (staffs) {
      var me = this, i, j, k, l, staff, x, y, w, y1;
      var STAFF_BOTTOM_OFFSET = 20;

      for (i = 0, j = staffs.length; i < j; i += 1) {
        if (staffs[i]) {
          for (k = 0, l = staffs[i].length; k < l; k += 1) {
            staff = staffs[i][k];
            if (staff) {
              x = staff.x;
              y = staff.y;
              w = staff.width;
              y1 = staff.getBottomY() - STAFF_BOTTOM_OFFSET;
              me.measureAreas.push({
                ctx : {
                  x : x,
                  y : y,
                  w : w,
                  h : y1 - y,
                  x1 : x + w,
                  y1 : y1
                },
                measureN : i,
                staffN : k
              });
              me.calculateBarlineAreas(staff, y, y1 - y);
              me.calculateStaffModifierAreas(staff, y, y1 - y);
            }
          }
        }
      }

    },

    calculateBarlineAreas : function (staff) {
      var me = this, staffY, staffH;

      staffY = staff.getYForLine(0) - 5;
      staffH = staff.getYForLine(4) - staffY + 10;

      if (staff.modifiers[0].barline !== 7) {
        me.barlineAreas.push(me.createNoteAreaObj(staff.modifiers[0].x - 8, staffY, 16, staffH, null, 1));
      }
      if (staff.modifiers[1].barline !== 7) {
        me.barlineAreas.push(me.createNoteAreaObj(staff.modifiers[1].x - 8, staffY, 16, staffH, null, 1));
      }
    },

    calculateStaffModifierAreas : function (staff, y, h) {
      var me = this, modifiers = staff.modifiers, i, j, category, x, w;
      j = modifiers.length;

      if (staff.modifiers.length > 2) {
        x = staff.glyph_start_x - 4;
        w = staff.start_x - staff.glyph_start_x + 8;
        me.measureModifierAreas.push(me.createNoteAreaObj(x, y, w, h, null, i));
      }

      // var lastX = staff.x;
      // var shift;
      //
      // window.x = staff;
      // for ( i = 2; i < j; i += 1) {
      //
      // console.log(modifiers[i]);
      //
      // if (modifiers[i]) {
      // shift = staff.getModifierXShift(0);
      // //
      // me.noteAreas.push(me.createNoteAreaObj(lastX, staffY, shift - lastX,
      // staffH, null, 1));
      // lastX = shift;
      //
      // }
      //
      // // console.log(modifiers[i]);
      // // console.log(me.createNoteAreaObj(x, y, w, h,
      // // modifiers[i].getMeiElement(), i));
      // }
    },

    calculateNoteAreas : function (notes) {
      var me = this, i, j, k, l, note, box, x, y, w, h, metrics, meiElement;
      for (i in notes) {
        note = notes[i].vexNote;
        meiElement = notes[i].meiNote;
        box = note.getBoundingBox();
        x = note.getAbsoluteX() - 10;
        y = box.y - 10;
        w = 30;
        h = box.h + 20;
        me.noteAreas.push(me.createNoteAreaObj(x, y, w, h, meiElement, i));
        me.calculateNoteModifierAreas(note);
      }
    },

    createNoteAreaObj : function (x, y, w, h, meiElement, xmlid) {
      return {
        ctx : {
          x : x,
          y : y,
          w : w,
          h : h,
          x1 : x + w,
          y1 : y + h
        },
        meiElement : meiElement,
        xmlid : xmlid
      };
    },

    calculateAnchoredTextAreas : function (texts) {
      var me = this;
      i = texts.length;
      while (i--) {
        me.anchoredTextAreas.push(texts[i].getArea());
      }
    },

    calculatePgHeadAreas : function (textsByLine) {
      var me = this, i, j, texts;
      j = textsByLine.length;
      while (j--) {
        texts = textsByLine[j];
        i = texts.length;
        while (i--) {
          me.pgHeadAreas.push(texts[i].getArea());
        }
      }
    },


    calculateNoteModifierAreas : function (note) {
      var me = this, modifiers = note.modifiers, i, category, x, y, w, h, areas = [];
      i = modifiers.length;
      while (i--) {
        category = modifiers[i].getCategory();
        switch (category) {
          case 'annotations':
            x = modifiers[i].x - 6;
            y = modifiers[i].y - 20;
            w = modifiers[i].text_width + 12;
            h = 30;
            me.noteAreas.push(me.createNoteAreaObj(x, y, w, h, modifiers[i].getMeiElement(), i));
            break;
          case 'articulations':
            w = modifiers[i].width + 8;
            h = w;
            x = modifiers[i].x - w / 2 - modifiers[i].articulation.shift_right;
            y = modifiers[i].y - h / 2 - modifiers[i].articulation.shift_down;
            me.noteAreas.push(me.createNoteAreaObj(x, y, w, h, modifiers[i].getMeiElement(), i));
            break;
          case 'dots':
          case 'accidentals':
          default:
            // console.log('not processed: ' + category);
            break;
        }
      }
    },

    calculateNoteModifierArea : function () {

    },

    calculateNoteArea : function (notes, xmlid) {
      var me = this, i, j, k, l, note, box, x, y, w, h;

      note = notes[xmlid].vexNote;
      box = note.getBoundingBox();

      x = note.getAbsoluteX() - 10;
      y = box.y - 10;
      w = 30;
      h = box.h + 20;
      return {
        ctx : {
          x : x,
          y : y,
          w : w,
          h : h,
          x1 : x + w,
          y1 : y + h
        },
        xmlid : xmlid
      };
    },

    /**
     * Calculates an area which contains all of the specified areas.
     * @param {Object[]} areas
     * @returns {{ctx: {x: number, y: number, x1: number, y1: number}, xmlids: Array}}
     */
    getSurroundingArea : function (areas) {
      var i = areas.length, ctx, xmlids = [];
      ctx = {
        x : 10000,
        y : 10000,
        x1 : 0,
        y1 : 0
      };
      while (i--) {
        xmlids.push(areas[i].xmlid);
        ctx.x = Math.min(ctx.x, areas[i].ctx.x);
        ctx.y = Math.min(ctx.y, areas[i].ctx.y);
        ctx.x1 = Math.max(ctx.x1, areas[i].ctx.x1);
        ctx.y1 = Math.max(ctx.y1, areas[i].ctx.y1);
      }
      ctx.w = ctx.x1 - ctx.x;
      ctx.h = ctx.y1 - ctx.y;
      return {
        ctx : ctx,
        xmlids : xmlids
      }
    },

    getVariantCoordinates : function (meiDoc) {
      var me = this, i, j, grp, area, areas, variantIdGrps;

      variantIdGrps = [];

      for (i in meiDoc.ALTs) {
        variantIdGrps.push({
          alt : meiDoc.ALTs[i],
          grp : me.getVariantIds(meiDoc.ALTs[i])
        });
      }

      i = variantIdGrps.length;
      while (i--) {
        grp = variantIdGrps[i].grp;
        areas = [];

        for (j in grp) {
          area = me.getIdCoordinates(j, grp[j]);
          if (area) {
            areas.push(area);
          }
        }
        var surroundingArea = me.getSurroundingArea(areas);
        surroundingArea.alt = variantIdGrps[i].alt;
        me.variantAreas.push(surroundingArea);
      }
    },


    // TODO is it necessary to attach ids to syllables etc or not!?
    getVariantIds : function (ALT) {
      var i, j, alt, id, idgroups = [], ids, defaultItem;
      defaultItem = ALT.getDefaultItem();
      ids = {};

      if (defaultItem) {
        alt = defaultItem.elem;
      } else {
        for (var alt in meiDoc.ALTs[i].altitems) {
          alt = meiDoc.ALTs[i].altitems[alt].elem;
          break;
        }
      }
      var elements = alt.getElementsByTagName('*');
      for (i = 0, j = elements.length; i < j; i += 1) {
        id = elements[i].getAttribute('xml:id');
        if (id) {
          ids[id] = elements[i].localName;
        }
      }
      return ids;
    },

    getIdCoordinates : function (xmlid, localName) {
      var me = this, area;
      switch (localName) {
        case 'note':
          return me.calculateNoteArea(me.viewer.converter.getNotes(), xmlid);
        case 'rest':
          return me.calculateNoteArea(me.viewer.converter.getNotes(), xmlid);
        case 'mRest':
          return me.calculateNoteArea(me.viewer.converter.getNotes(), xmlid);
        case 'syl':

        default:
          return;
      }
    }
  };


  var Text = function (meiElement, opts, overrideOpts, customText, meiNodeMatch) {
    this.init(meiElement, opts, overrideOpts, customText, meiNodeMatch);
  };

  Text.prototype = {

    init : function (meiElement, opts, overrideOpts, customText, meiNodeMatch) {
      var me = this, atts;
      me.meiElement = meiElement;
      me.meiNodeMatch = meiNodeMatch;
      atts = (overrideOpts) ? opts : $.extend({}, opts, m2v.Util.attsToObj(meiElement));
      me.x = +atts.x;
      me.y = +atts.y;
      me.textAlign = atts.halign || 'left';
      me.text = (customText === undefined) ? $(meiElement).text() : customText;
      me.atts = atts;
    },

    setX : function (x) {
      this.x = x;
    },

    setY : function (y) {
      this.y = y;
    },

    setTextAlign :function (textAlign) {
    this.textAlign = textAlign;
  },

    getArea : function () {
      var me = this;

      return {
        ctx : {
          x : me.x - 6,
          y : me.y - me.h,
          w : me.w + 12,
          h : me.h + 8,
          x1 : me.x + me.w + 6,
          y1 : me.y + 8
        },
        meiElement : me.meiElement,
        meiNodeMatch : me.meiNodeMatch,
        xmlid : null
      };
    },

    setContext : function (ctx) {
      this.ctx = ctx;
      return this;
    },

    preProcess : function () {
      var me = this, ctx = me.ctx, atts = me.atts;
      this.font =
        atts.fontstyle + ' ' + atts.fontweight + ' ' + atts.fontsize + 'px ' + atts.fontfamily;
      ctx.font = this.font;
      me.h = atts.fontsize;
      me.w = ctx.measureText(me.text).width;
      return this;
    },

    draw : function () {
      var me = this;
      me.ctx.textAlign = me.textAlign;
      me.ctx.font = me.font;
      me.ctx.fillText(me.text, me.x, me.y);
    }

  };


  /**
   * @class MEI2TEXT.AnchoredTexts
   * @private
   *
   * @constructor
   */
  var AnchoredTexts = function (font) {
    var me = this;

    me.font = font;

    me.allTexts = [];
  };

  AnchoredTexts.prototype = {

    getAll : function () {
      return this.allTexts;
    },

    /**
     * Creates a model object from an element and adds it to {@link #allTexts}
     * @param {Element} element
     */
    addText : function (element) {
      var me = this;
      me.allTexts.push(new Text(element, {
        fontfamily: me.font.family,
        fontweight: me.font.weight,
        fontsize: me.font.size,
        fontstyle: ''
      }));
    },

    /**
     * Gets an element's first ancestor with the specified localName
     * @param {Element} element the start element
     * @param {String} localName the localName of the ancestor
     * @returns {Element}
     */
    getAncestor : function (element, localName) {
      while (( element = element.parentElement) && (element.localName !== localName)) {}
      return element;
    },

    // TODO better get container elements by id!?!?
    getContainer : function (element, allVexMeasureStaffs) {
      var me = this, staff, measure, measure_n, staff_n;
      staff = me.getAncestor(element, 'staff');
      if (staff) {
        measure = me.getAncestor(staff, 'measure');
        if (measure) {
          measure_n = measure.getAttribute('n') || '1';
          staff_n = staff.getAttribute('n') || '1';
          return allVexMeasureStaffs[measure_n][staff_n];
        }
      }
      return null;
    },

    setContext : function (ctx) {
      this.ctx = ctx;
      return this;
    },

    draw : function (allVexMeasureStaffs) {
      var me = this, x, y, staff, ctx = me.ctx;
      $.each(me.allTexts, function () {

        if (!this.y) {
          staff = me.getContainer(this.meiElement, allVexMeasureStaffs);
          this.setY(staff.getYForLine(3) - 4 + (+this.atts.vo * staff.getSpacingBetweenLines() / 2 || 0));
        }
        if (!this.x) {
          if (!staff) {
            staff = me.getContainer(this.meiElement, allVexMeasureStaffs);
          }
          this.setX(staff.glyph_start_x + (+this.atts.ho * staff.getSpacingBetweenLines() / 2 || 0));
        }

        this.setContext(ctx).preProcess().draw();

      });
    }
  };


  /**
   * @class MEI2TEXT.MeasureNumbers
   * @private
   *
   * @constructor
   */
  var MeasureNumbers = function (font) {
    this.font = font;
  };

  MeasureNumbers.prototype = {

    addToSystemStarts : function (systems) {
      var me = this, i, measure, n;
      i = systems.length;
      while (i--) {
        if (systems[i]) {
          measure = systems[i].getMeasure(0);
          n = measure.getN();
          if (n > 1) {
            measure.getFirstDefinedStaff().setMeasure(n).font = me.font;
          }
        }
      }
    }
  };


  /**
   * @class MEI2TEXT.PgHead
   * @private
   *
   * @constructor
   */
  var PgHead = function (element, coords) {
    this.init(element, coords);
  };

  PgHead.prototype = {

    init : function (element, coords) {
      var me = this;
      me.defaultFontSize = 25;
      me.lineHeight = 1.3;

      // TODO treat rend[@align]s like floating HTML divs
      /**
       * Contains the MSV.Text objects ordered by line number. Each descendant text node
       * of the pgHead element is stored in its own Text object
       * @type {Text[][]}
       */
      me.textsByLine = [
        []
      ];
      me.line_n = 0;

      me.htmlToArray(element, {
        fontsize : me.defaultFontSize,
        fontweight : '',
        fontstyle : '',
        fontfamily : 'Times'
      });

      /**
       * @property {Number} x The x coordinate of the page head area
       */
      me.x = coords.x;
      /**
       * @property {Number} y The y coordinate of the page head area
       */
      me.y = coords.y;
      /**
       * @property {Number} w The width of the page head area
       */
      me.w = coords.w;

      /**
       * Current coordinates
       * @type {{x: *, y: *, w: *}}
       */
      me.currentCoords = coords;

    },

    getTextsByLine : function () {
      return this.textsByLine;
    },


    htmlToArray : function (element, opts) {
      var me = this, atts, defaults, text, i, j, childNodes, nodeMatch;

      childNodes = element.childNodes;

      for (i = 0, j = childNodes.length; i < j; i++) {

        if (childNodes[i].nodeName === '#text') {
          text = childNodes[i].textContent.replace(/([\n|\r]+\s*)/g, '');
          if (text) {
            // MSV.Text always expects an element as the first argument; we pass
            // the parent element of the current text node. If the parent
            // element contains more than one child, a nodeMatch parameter is
            // added; this way, the text node in concern can laber be addressed
            // unambiguously by evaluating element and nodeMatch.
            nodeMatch = (j === 1) ? null : {type : 'child', value : i};
            me.textsByLine[me.line_n].push(new Text(element, opts, true, text, nodeMatch));
          }
        } else {
          switch (childNodes[i].localName) {
            case undefined :
              break;
            case 'lb' :
              me.breakLine();
              break;
            case 'title' :
              atts = m2v.Util.attsToObj(childNodes[i]);
              defaults = {
                halign : 'center',
                fontsize : (atts.type === 'sub') ? 35 : 50,
                fontweight : 'Bold'
              };
              me.htmlToArray(childNodes[i], $.extend({}, opts, defaults, atts));
              me.breakLine();
              break;
            default :
              me.htmlToArray(childNodes[i], $.extend({}, opts, m2v.Util.attsToObj(childNodes[i])));
          }
        }
      }
    },

    breakLine : function () {
      var me = this;
      me.line_n += 1;
      me.textsByLine[me.line_n] = [];
    },

    setContext : function (ctx) {
      this.ctx = ctx;
      return this;
    },

    draw : function () {
      var me = this, leftTexts, centerTexts, rightTexts, maxFontSizeInLine, i;

      currentCoords = me.currentCoords;

      var processTextLine = function () {
        leftTexts = [];
        centerTexts = [];
        rightTexts = [];
        maxFontSizeInLine = 0;
        $.each(this, function () {
          this.setContext(me.ctx).preProcess();
          this.setTextAlign('left');
          switch (this.atts.halign) {
            case 'center' :
              centerTexts.push(this);
              break;
            case 'right' :
              rightTexts.push(this);
              break;
            default :
              leftTexts.push(this);
          }
        });

        maxFontSizeInLine =
        Math.max(me.drawCenterTexts(centerTexts, currentCoords), me.drawRightAlignedTexts(rightTexts, currentCoords), me.drawLeftAlignedTexts(leftTexts, currentCoords));

        currentCoords.y += maxFontSizeInLine * me.lineHeight;
      };

      $.each(me.textsByLine, processTextLine);
    },

    drawCenterTexts : function (centerTexts, currentCoords) {
      var me = this, maxFontSize, totalTextWidth = 0, i;

      i = centerTexts.length;
      while (i--) {
        totalTextWidth += centerTexts[i].w;
      }

      maxFontSize = me.drawLeftAlignedTexts(centerTexts, {
        x : currentCoords.x + (currentCoords.w / 2) - (totalTextWidth / 2),
        y : currentCoords.y,
        w : currentCoords.w
      }, me.ctx);
      return maxFontSize;
    },

    drawRightAlignedTexts : function (rightTexts, currentCoords) {
      var me = this, maxH = 0, offsetX = 0, obj, i;
      i = rightTexts.length;
      while (i--) {
        obj = rightTexts[i];
        offsetX += obj.w;
        obj.setX(currentCoords.x + currentCoords.w - offsetX);
        obj.setY(currentCoords.y);
        obj.draw();
        maxH = Math.max(obj.h, maxH);
      }
      return maxH;
    },

    drawLeftAlignedTexts : function (leftTexts, currentCoords) {
      var me = this, maxH = 0, offsetX = 0;
      $.each(leftTexts, function (i, obj) {
        obj.setX(currentCoords.x + offsetX);
        obj.setY(currentCoords.y);
        obj.draw();
        offsetX += obj.w;
        maxH = Math.max(obj.h, maxH);
      });
      return maxH;
    }

  };


  /**
   * @class MSV.Viewer
   *
   * @constructor
   * @param {Object} config For a full list, see the config options of the
   * Viewer object as well as the converter options at {@link MEI2VF.Converter
     * MEI2VF.Converter}
   */
  var Viewer = function (config) {
    this.init(config);
  };

  Viewer.prototype = {

    defaults : {
      /**
       * @cfg {Number} page_scale The page scale (set 1 for 100%, 0.5 for 50%
       * etc.)
       */
      page_scale : 1,
      /**
       * @cfg {Number} page_height The height of the page.
       */
      page_height : 350,
      /**
       * @cfg {Number} page_width The width of the page.
       */
      page_width : 800,
      /**
       * @cfg {Boolean} autoMeasureNumbers Specifies if measure numbers should
       * automatically be added to each system start
       */
      autoMeasureNumbers : false,
      /**
       * @cfg {Object} measureNumberFont The staff font (used for barlines)
       * @cfg {String} measureNumberFont.family the font family
       * @cfg {Number} measureNumberFont.size the font size
       * @cfg {String} measureNumberFont.weight the font weight
       */
      measureNumberFont : {
        family : 'Times',
        size : 14,
        weight : 'Italic'
      },
      /**
       * @cfg {Object} anchoredTextFont The anchored text font
       * @cfg {String} anchoredTextFont.family the font family
       * @cfg {Number} anchoredTextFont.size the font size
       * @cfg {String} anchoredTextFont.weight the font weight
       */
      anchoredTextFont : {
        family : 'Times',
        size : 22,
        weight : ''
      },
      /**
       * @cfg {Object} staff Staff options (For details, see the comments in VexFlow's `stave.js`)
       */
      staff : {
        fill_style : "#000000"
      },
      /**
       * @cfg (Boolean) useMeiLib Specifies if the MeiLib library should be used.
       * Set this only to false if there are no variants in the MEI document.
       */
      useMeiLib : true,
      /**
       * @cfg {Boolean} checkXmlIds If set to false, the check run for missing
       * xml:ids will be skipped. Xml:ids are necessary for the
       * viewer to work: Set this option only to `false` if you are sure that
       * no xml:ids are missing in the input file.
       */
      checkXmlIds : true,
      /**
       * @cfg {String} xmlIdPrefix The prefix of the xml:ids added by the
       * viewer. Needs only to be changed if {@link #checkXmlIds} is `true` and
       * the processed MEI document contains xml:ids starting with `M2V`.
       */
      xmlIdPrefix : 'M2V',
      /**
       * @cfg {Object[]} layers The canvas layers. (optional)
       *
       * Can be either a subclass of {@link MSV.AreaCollection} like
       * {@link MSV.DefaultAreaCollection} or, to specify the layer to contain
       * the VexFlow output, an object with the property `type` with the value `vex`.
       * The first layer will be the bottom-most, the last one the top-most.
       * If no VexFlow layer is specified, a VexFlow Layer gets added automatically
       * as the top-most layer.
       */
      layers : []
    },

    init : function (config) {
      var me = this, xmlDoc, firstScoreDef, cfg, canvas, ctx, meiDoc, layers;

      if (!config) {
        throw new RuntimeError('NoConfig', 'No config passed to Viewer.');
      }

      if (!config.xmlDoc) {
        throw new RuntimeError('MissingData', 'No XML document passed to Viewer.');
      }

      xmlDoc = Document.initXmlDoc(config.xmlDoc);

      window.xx = xmlDoc;

      firstScoreDef = xmlDoc.getElementsByTagName('scoreDef')[0];
      if (!firstScoreDef) {
        throw new RuntimeError('BadMEIFile', 'No <scoreDef> found in config.data.');
      }

      me.cfg = $.extend(true, {}, me.defaults, Document.getMEIPageConfig(firstScoreDef), config);

      if (me.cfg.checkXmlIds) {
        Document.ascertainDescendantIds(xmlDoc, me.cfg.xmlIdPrefix);
      }

      if (me.cfg.useMeiLib) {
        meiDoc = new MeiLib.MeiDoc(xmlDoc);
        meiDoc.initSectionView();
        me.convertMEI(meiDoc.sectionview_score);
      } else {
        me.convertMEI(xmlDoc);
      }

      me.UI = new UI();
      layers = me.UI.createLayers(me.cfg);

      me.drawMEI(layers[me.UI.vexLayerIndex].ctx);

      me.areaHelper = new AreaHelper(me);
      me.areaHelper.setAreas(meiDoc, layers);

      me.registerMouseHandlers(me.UI, layers);
    },

    registerMouseHandlers : function (UI, layers) {
      var me = this, i, layer;
      i = layers.length;
      while (i--) {
        layer = layers[i];
        if (layer.type === 'highlighter') {
          if (layer.clickHandler) {
            UI.registerMouseClickHandler(layer);
          }
          if (layer.highlightMode === 'hover' || (layer.mouseEnterHandler && layer.mouseLeaveHandler)) {
            UI.registerMouseMoveHandler(layer);
          }
        }
      }
      UI.listenMouseClick();
      UI.listenMouseMove();
    },

    convertMEI : function (xmlDoc, vexCtx) {
      var me = this;
      /**
       * @property {MEI2VF.Converter} converter the MEI2VF converter
       */
      me.converter = new m2v.Converter(me.cfg);
      me.anchoredTexts = new AnchoredTexts(me.cfg.anchoredTextFont);

      // TODO add behaviour: when no top coords are specified, make beginning
      // of music relative to pgHead

      var headEl = xmlDoc.getElementsByTagName('pgHead')[0];

      if (headEl) {
        me.pgHead = new PgHead(headEl, {
          x : me.converter.printSpace.left,
          y : 200,
          w : me.converter.printSpace.width
        });
      }

      me.converter.process(xmlDoc);

      if (me.cfg.autoMeasureNumbers) {
        me.measureNumbers = new MeasureNumbers(me.cfg.measureNumberFont);
        me.measureNumbers.addToSystemStarts(me.converter.getSystems());
      }

      me.allVexMeasureStaffs = me.converter.getAllVexMeasureStaffs();

      var anchoredTextEls = xmlDoc.getElementsByTagName('anchoredText');
      for (var i=0, j = anchoredTextEls.length; i<j;i++){
        me.anchoredTexts.addText(anchoredTextEls[i]);
      }

    },

    drawMEI : function (ctx) {
      var me = this;
      me.converter.draw(ctx);
      if (me.pgHead) me.pgHead.setContext(ctx).draw();
      me.anchoredTexts.setContext(ctx).draw(me.allVexMeasureStaffs);
    }

  };


  /**
   * @class MSV.AbstractAreaCollection
   */
  var AbstractAreaCollection = function (config) {

  };

  AbstractAreaCollection.prototype = {

    setElement : function (element) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for setElement() provided.');
    },

    setContext : function (ctx) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for setContext() provided.');
    },

    setScale : function (scale) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for setScale() provided.');
    },

    addAreas : function (areas) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for addAreas() provided.');
    },

    initHighlights : function () {
      throw new RuntimeError('AbstractAreaCollection', 'No override for initHighlights() provided.');
    },

    removeHighlight : function () {
      throw new RuntimeError('AbstractAreaCollection', 'No override for removeHighlight() provided.');
    },

    onClick : function (mousePos, topCanvas, e) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for onClick() provided.');
    },

    onMouseMove : function (mousePos, topCanvas, e) {
      throw new RuntimeError('AbstractAreaCollection', 'No override for onMouseMove() provided.');
    }

  };


  /**
   * @class MSV.DefaultAreaCollection
   */
  var DefaultAreaCollection = function (config) {
    this.init(config);
  };

  Vex.Inherit(DefaultAreaCollection, AbstractAreaCollection, {

    type : 'highlighter',

    /**
     * @property {Object} emptyArea An area in which all dimensions are set to
     * zero.
     */
    emptyArea : {
      ctx : {
        x : 0,
        y : 0,
        w : 0,
        h : 0
      }
    },

    init : function (config) {
      var me = this;
      me.ctx = config.ctx;

      me.content = config.content;

      me.highlightMode = config.highlightMode;

      me.fillStyle = config.fillStyle || 'rgba(100, 100, 0, 0.5)';

      me.clickHandler = config.clickHandler;
      me.mouseEnterHandler = config.mouseEnterHandler;
      me.mouseLeaveHandler = config.mouseLeaveHandler;

      me.currentHighlight = me.emptyArea;
      return me;
    },

    setElement : function (element) {
      this.element = element;
    },

    setContext : function (ctx) {
      var me = this;
      me.ctx = ctx;
      me.ctx.fillStyle = me.fillStyle;
    },

    setScale : function (scale) {
      this.scale = scale;
    },

    getAreas : function () {
      return this.areas;
    },

    addAreas : function (areas) {
      if (this.areas) {
        Array.prototype.push.apply(this.areas, areas);
      } else {
        this.areas = areas;
      }
    },

    initHighlights : function () {
      var me = this;
      if (me.highlightMode === 'static') {
        me.highlightAll();
      } else if (me.highlightMode === 'hover') {
        me.highlightOnHover = true;
      }
    },

    removeHighlight : function () {
      var me = this;
      me.ctx.clearRect(me.currentHighlight.ctx.x - 1, me.currentHighlight.ctx.y - 1, me.currentHighlight.ctx.w +
                                                                                     2, me.currentHighlight.ctx.h + 2);
    },

    highlightAll : function () {
      var me = this, i;
      i = me.areas.length;
      while (i--) {
        me.setHighlight(me.areas[i]);
      }
    },

    onClick : function (mousePos, topCanvas, e) {
      var me = this, area;
      area = me.getAreaFromPoint(mousePos);
      if (area) {
        return me.clickHandler(area, topCanvas, e);
      }
      return true;
    },

    onMouseMove : function (mousePos, topCanvas, e) {
      var me = this, area;
      area = me.getAreaFromPoint(mousePos);
      if (area) {
        if (me.currentHighlight !== area) {
          if (me.highlightOnHover) {
            me.removeHighlight();
            me.setHighlight(area);
          }
          ;
          if (me.mouseEnterHandler) {
            me.mouseEnterHandler(area, topCanvas, e);
          }
        }
      } else {
        if (me.currentHighlight !== me.emptyArea) {
          if (me.highlightOnHover) {
            me.removeHighlight();
            me.setHighlight(me.emptyArea);
          }
          if (me.mouseLeaveHandler) {
            me.mouseLeaveHandler(null, topCanvas, e);
          }
        }
      }
    },

    /**
     * Highlights an area.
     * @param {Object} area The area to highlight.
     */
    setHighlight : function (area) {
      var me = this;

      //      me.ctx.fillRect(area.ctx.x, area.ctx.y, area.ctx.w, area.ctx.h);
      me.roundRect(me.ctx, area.ctx.x, area.ctx.y, area.ctx.w, area.ctx.h, 5, true, false);

      me.currentHighlight = area;
    },

    // From http://js-bits.blogspot.de/2010/07/canvas-rounded-corner-rectangles.html
    /**
     * Draws a rounded rectangle using the current state of the canvas.
     * If you omit the last three params, it will draw a rectangle
     * outline with a 5 pixel border radius
     * @param {CanvasRenderingContext2D} ctx
     * @param {Number} x The top left x coordinate
     * @param {Number} y The top left y coordinate
     * @param {Number} width The width of the rectangle
     * @param {Number} height The height of the rectangle
     * @param {Number} radius The corner radius. Defaults to 5;
     * @param {Boolean} fill Whether to fill the rectangle. Defaults to false.
     * @param {Boolean} stroke Whether to stroke the rectangle. Defaults to true.
     */
    roundRect : function (ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke == "undefined") {
        stroke = true;
      }
      if (typeof radius === "undefined") {
        radius = 5;
      }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (stroke) {
        ctx.stroke();
      }
      if (fill) {
        ctx.fill();
      }
    },

    /**
     * Checks if a point is in one of the highlighter areas. If so, the inFn
     * callback function will be called, otherwise the outFn.
     * @param {Object} point The point
     * @param {Number} point.x The x coordinate
     * @param {Number} point.y The y coordinate
     * @return {Object|null} The last area the point is in or null if the point
     * is in none of the highlighter's areas.
     */
    getAreaFromPoint : function (point) {
      var me = this, areas, i, inArea = false;
      areas = me.areas;
      i = areas.length;
      while (i--) {
        if (me.isPointInRect(point, areas[i].ctx)) {
          return areas[i];
        }
      }
      return null;
    },

    /**
     * Checks if a point is in a rectangle
     * @param {Object} point the coordinates of a point
     * @param {Object} point.x the x coordinate
     * @param {Object} point.y the y coordinate
     * @param {Object} rect the coordinates of the rectangle
     * @param {Object} rect.x the left x coordinate
     * @param {Object} rect.y the top y coordinate
     * @param {Object} rect.x1 the right x coordinate
     * @param {Object} rect.y1 the bottom y coordinate
     * @return {Boolean} True if the mouse is within the rectangle, otherwise
     * false.
     */
    isPointInRect : function (point, rect) {
      return !(point.x < rect.x || point.x > rect.x1 || point.y < rect.y || point.y > rect.y1);
    }
  });


  Vex.Flow.Annotation.prototype.setMeiElement = function (element) {
    this.meiElement = element;
    return this;
  };
  Vex.Flow.Annotation.prototype.getMeiElement = function () {
    return this.meiElement;
  };
  Vex.Flow.Articulation.prototype.setMeiElement = function (element) {
    this.meiElement = element;
    return this;
  };
  Vex.Flow.Articulation.prototype.getMeiElement = function () {
    return this.meiElement;
  };


  MEI2VF.Converter.prototype.dirToObj = function (elements) {
    var me = this, directions = [];
    $.each(elements, function () {
      directions.push({
        text : $(this).text().trim(),
        startid : me.getMandatoryAttr(this, 'startid'),
        place : me.getMandatoryAttr(this, 'place'),
        element : this
      });
    });
    return directions;
  };


  MEI2VF.Directives.prototype.createVexFromInfos = function(notes_by_id) {
    var me = this, i, model, note, annot;
    i = me.allModels.length;
    while (i--) {
      model = me.allModels[i];
      note = notes_by_id[model.startid];
      if (note) {
        annot = (new VF.Annotation($(model.element).text().trim())).setFont(me.font.family, me.font.size, me.font.weight).setMeiElement(model.element);

        // TEMPORARY: set width of modifier to zero so voices with modifiers
        // don't get too much width; remove when the width calculation in
        // VexFlow does distinguish between different y values when
        // calculating the width of tickables
        annot.setWidth(0);
        if (model.atts.place === 'below') {
          note.vexNote.addAnnotation(0, annot.setVerticalJustification(me.BOTTOM));
        } else {
          note.vexNote.addAnnotation(0, annot);
        }
      } else {
        throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.createVexFromInfos', "The reference in the directive could not be resolved.");
      }
    }
  };

  MEI2VF.Dynamics.prototype.createVexFromInfos = function(notes_by_id) {
    var me = this, i, model, note, annot;
    i = me.allModels.length;
    while (i--) {
      model = me.allModels[i];
      note = notes_by_id[model.startid];
      if (note) {
        annot = (new VF.Annotation($(model.element).text().trim())).setFont(me.font.family, me.font.size, me.font.weight).setMeiElement(model.element);
        if (model.atts.place === 'above') {
          note.vexNote.addAnnotation(0, annot);
        } else {
          note.vexNote.addAnnotation(0, annot.setVerticalJustification(me.BOTTOM));
        }
      } else {
        throw new m2v.RUNTIME_ERROR('MEI2VF.RERR.createVexFromInfos', "The reference in the directive could not be resolved.");
      }
    }
  };


  MEI2VF.Converter.prototype.processSyllable = function (mei_note) {
    var syl = mei_note.getElementsByTagName('syl')[0];
    if (syl) {
      return {
        text : $(syl).text(),
        wordpos : syl.getAttribute('wordpos'),
        element : syl
      };
    }
  };

  MEI2VF.Converter.prototype.processSyllables = function (note, element, staff_n) {
    var me = this, annot, syl;
    syl = me.processSyllable(element);
    if (syl) {
      annot =
      me.createAnnot(syl.text, me.cfg.lyricsFont).setMeiElement(syl.element).setVerticalJustification(me.BOTTOM);
      note.addAnnotation(0, annot);
      if (syl.wordpos) {
        me.hyphenation.addSyllable(annot, syl.wordpos, staff_n);
      }
    }
  };

  MEI2VF.Converter.prototype.addArticulation = function (note, ar) {
    var vexArtic = new VF.Articulation(m2v.tables.articulations[ar.getAttribute('artic')]).setMeiElement(ar);
    var place = ar.getAttribute('place');
    if (place) {
      vexArtic.setPosition(m2v.tables.positions[place]);
    }
    note.addArticulation(0, vexArtic);
  };

  MEI2VF.Fermatas.prototype.addFermataToNote = function (note, place, index) {
    var vexArtic = new VF.Articulation(m2v.tables.fermata[place]);
    vexArtic.setPosition(m2v.tables.positions[place]);
    note.addArticulation(index || 0, vexArtic);
  };

  //  MEI2VF.Converter.prototype.addFermata = function(note, place, index) {
  //  var vexArtic = new VF.Articulation(m2v.tables.fermata[place]);
  //  vexArtic.setPosition(m2v.tables.positions[place]);
  //  vexArtic.setMeiElement(ar);
  //  note.addArticulation(index || 0, vexArtic);
  //  };



  VF.Articulation.prototype.draw = function() {
    var Modifier = Vex.Flow.Modifier;
    var L = function() {};
    if (!this.context) throw new Vex.RERR("NoContext",
      "Can't draw Articulation without a context.");
    if (!(this.note && (this.index !== null))) throw new Vex.RERR("NoAttachedNote",
      "Can't draw Articulation without a note and index.");

    var stem_direction = this.note.getStemDirection();
    var stave = this.note.getStave();

    var is_on_head = (this.position === Modifier.Position.ABOVE &&
                      stem_direction === Vex.Flow.StaveNote.STEM_DOWN) ||
                     (this.position === Modifier.Position.BELOW &&
                      stem_direction === Vex.Flow.StaveNote.STEM_UP);

    var needsLineAdjustment = function(articulation, note_line, line_spacing) {
      var offset_direction = (articulation.position === Modifier.Position.ABOVE) ? 1 : -1;
      var duration = articulation.getNote().getDuration();

      if(!is_on_head && duration !== "w" && duration !== "1"){
        // Add stem length, inless it's on a whole note
        note_line += offset_direction * 3.5;
      }

      var articulation_line = note_line + (offset_direction * line_spacing);

      if(articulation_line >= 1 &&
         articulation_line <= 5 &&
         articulation_line % 1 === 0){
        return true;
      }

      return false;
    };

    // Articulations are centered over/under the note head.
    var start = this.note.getModifierStartXY(this.position, this.index);
    var glyph_y = start.y;
    var shiftY = 0;
    var line_spacing = 1;
    var spacing = stave.getSpacingBetweenLines();
    var is_tabnote = this.note.getCategory() === 'tabnotes';
    var stem_ext = this.note.getStem().getExtents();

    var top = stem_ext.topY;
    var bottom = stem_ext.baseY;

    if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN) {
      top = stem_ext.baseY;
      bottom = stem_ext.topY;
    }

    // TabNotes don't have stems attached to them. Tab stems are rendered
    // outside the stave.
    if (is_tabnote) {
      if (this.note.hasStem()){
        if (stem_direction === Vex.Flow.StaveNote.STEM_UP) {
          bottom = stave.getYForBottomText(this.text_line - 2);
        } else if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN ) {
          top = stave.getYForTopText(this.text_line - 1.5);
        }
      } else { // Without a stem
        top = stave.getYForTopText(this.text_line - 1);
        bottom = stave.getYForBottomText(this.text_line - 2);
      }
    }

    var is_above = (this.position === Modifier.Position.ABOVE) ? true : false;
    var note_line = this.note.getLineNumber(is_above);

    // Beamed stems are longer than quarter note stems.
    if (!is_on_head && this.note.beam) line_spacing += 0.5;

    // If articulation will overlap a line, reposition it.
    if (needsLineAdjustment(this, note_line, line_spacing)) line_spacing += 0.5;

    var glyph_y_between_lines;
    if (this.position === Modifier.Position.ABOVE) {
      shiftY = this.articulation.shift_up;
      glyph_y_between_lines = (top - 7) - (spacing * (this.text_line + line_spacing));

      if (this.articulation.between_lines)
        glyph_y = glyph_y_between_lines;
      else
        glyph_y = Math.min(stave.getYForTopText(this.text_line) - 3, glyph_y_between_lines);
    } else {
      shiftY = this.articulation.shift_down - 10;

      glyph_y_between_lines = bottom + 10 + spacing * (this.text_line + line_spacing);
      if (this.articulation.between_lines)
        glyph_y = glyph_y_between_lines;
      else
        glyph_y = Math.max(stave.getYForBottomText(this.text_line), glyph_y_between_lines);
    }

    var glyph_x = start.x + this.articulation.shift_right;
    glyph_y += shiftY + this.y_shift;

    L("Rendering articulation: ", this.articulation, glyph_x, glyph_y);
    Vex.Flow.renderGlyph(this.context, glyph_x, glyph_y,
      this.render_options.font_scale, this.articulation.code);

    // ### START ADDITION
    this.x = glyph_x;
    this.y = glyph_y;
    // ### END ADDITION

  };

















  // ### modifications for center aligned mRests by Silverwolf90
  // ### (remove when his pull request is merged in VexFlow!)

  VF.TickContext.prototype.init = function() {
    this.currentTick = new Vex.Flow.Fraction(0, 1);
    this.maxTicks = new Vex.Flow.Fraction(0, 1);
    this.minTicks = null;
    this.width = 0;
    this.padding = 3;     // padding on each side (width += padding * 2)
    this.pixelsUsed = 0;
    this.x = 0;
    this.tickables = [];   // Notes, tabs, chords, lyrics.
    this.notePx = 0;       // width of widest note in this context
    this.extraLeftPx = 0;  // Extra left pixels for modifers & displace notes
    this.extraRightPx = 0; // Extra right pixels for modifers & displace notes

    // ### START ADDITION
    this.align_center = false;
    // ### END ADDITION

    this.tContexts = [];   // Parent array of tick contexts

    // Ignore this tick context for formatting and justification
    this.ignore_ticks = true;
    this.preFormatted = false;
    this.postFormatted = false;
    this.context = null; // Rendering context
  };

  // ### START ADDITION
  VF.TickContext.prototype.getCenterAlignedTickables = function() {
    return this.tickables.filter(function(tickable) {
      return tickable.isCenterAligned();
    });
  };
  // ### END ADDITION

  VF.Tickable.prototype.init = function() {
    this.intrinsicTicks = 0;
    this.tickMultiplier = new Vex.Flow.Fraction(1, 1);
    this.ticks = new Vex.Flow.Fraction(0, 1);
    this.width = 0;
    this.x_shift = 0; // Shift from tick context
    this.voice = null;
    this.tickContext = null;
    this.modifierContext = null;
    this.modifiers = [];
    this.preFormatted = false;
    this.postFormatted = false;
    this.tuplet = null;
    // ### START ADDITION
    this.align_center = false;
    // ### END ADDITION

    // This flag tells the formatter to ignore this tickable during
    // formatting and justification. It is set by tickables such as BarNote.
    this.ignore_ticks = false;
    this.context = null;
  };

  // ### START ADDITION
  VF.Tickable.prototype.isCenterAligned = function() { return this.align_center; };
  VF.Tickable.prototype.setCenterAlignment = function(align_center) {
    this.align_center = align_center;
    return this;
  };
  VF.Tickable.prototype.setDuration = function(duration) {
    var ticks = duration.numerator * (Vex.Flow.RESOLUTION / duration.denominator);
    this.ticks = this.tickMultiplier.clone().multiply(ticks);
    this.intrinsicTicks = this.ticks.value();
  };
  // ### END ADDITION

  VF.Note.prototype.init = function(note_struct) {
    VF.Note.superclass.init.call(this);

    if (!note_struct) {
      throw new Vex.RuntimeError("BadArguments",
          "Note must have valid initialization data to identify " +
          "duration and type.");
    }

    // Parse `note_struct` and get note properties.
    var initData = Vex.Flow.parseNoteData(note_struct);
    if (!initData) {
      throw new Vex.RuntimeError("BadArguments",
          "Invalid note initialization object: " + JSON.stringify(note_struct));
    }

    // Set note properties from parameters.
    this.duration = initData.duration;
    this.dots = initData.dots;
    this.noteType = initData.type;

    // ### START MODIFICATION
    if (note_struct.duration_override) {
      // Custom duration
      this.setDuration(note_struct.duration_override);
    } else {
      // Default duration
      this.setIntrinsicTicks(initData.ticks);
    }
    // ### END MODIFICATION

    this.modifiers = [];

    // Get the glyph code for this note from the font.
    this.glyph = Vex.Flow.durationToGlyph(this.duration, this.noteType);

    if (this.positions &&
        (typeof(this.positions) != "object" || !this.positions.length)) {
      throw new Vex.RuntimeError(
        "BadArguments", "Note keys must be array type.");
    }

    // Note to play for audio players.
    this.playNote = null;

    // Positioning contexts used by the Formatter.
    this.tickContext = null;    // The current tick context.
    this.modifierContext = null;
    this.ignore_ticks = false;

    // Positioning variables
    this.width = 0;             // Width in pixels calculated after preFormat
    this.extraLeftPx = 0;       // Extra room on left for offset note head
    this.extraRightPx = 0;      // Extra room on right for offset note head
    this.x_shift = 0;           // X shift from tick context X
    this.left_modPx = 0;        // Max width of left modifiers
    this.right_modPx = 0;       // Max width of right modifiers
    this.voice = null;          // The voice that this note is in
    this.preFormatted = false;  // Is this note preFormatted?
    this.ys = [];               // list of y coordinates for each note
    // we need to hold on to these for ties and beams.

    // ### START ADDITION
    if (note_struct.align_center) {
      this.setCenterAlignment(note_struct.align_center);
    }
    // ### END ADDITION

    // The render surface.
    this.context = null;
    this.stave = null;
    this.render_options = {
      annotation_spacing: 5,
      stave_padding: 12
    };
  };


  VF.Formatter.prototype.preFormat = function(justifyWidth, rendering_context, voices, stave) {
    // Initialize context maps.
    var contexts = this.tContexts;
    var contextList = contexts.list;
    var contextMap = contexts.map;

    // If voices and a stave were provided, set the Stave for each voice
    // and preFormat to apply Y values to the notes;
    if (voices && stave) {
      voices.forEach(function(voice) {
        voice.setStave(stave);
        voice.preFormat();
      });
    }

    // Figure out how many pixels to allocate per tick.
    if (!justifyWidth) {
      justifyWidth = 0;
      this.pixelsPerTick = 0;
    } else {
      this.pixelsPerTick = justifyWidth / (this.totalTicks.value() * contexts.resolutionMultiplier);
    }

    // Now distribute the ticks to each tick context, and assign them their
    // own X positions.
    var x = 0;

    // ### START ADDITION
    var center_x = justifyWidth / 2;
    // ### END ADDITION

    var white_space = 0; // White space to right of previous note
    var tick_space = 0;  // Pixels from prev note x-pos to curent note x-pos
    var prev_tick = 0;
    var prev_width = 0;
    var lastMetrics = null;
    var initial_justify_width = justifyWidth;
    this.minTotalWidth = 0;

    var i, tick, context;

    // Pass 1: Give each note maximum width requested by context.
    for (i = 0; i < contextList.length; ++i) {
      tick = contextList[i];
      context = contextMap[tick];
      if (rendering_context) context.setContext(rendering_context);

      // Make sure that all tickables in this context have calculated their
      // space requirements.
      context.preFormat();

      var thisMetrics = context.getMetrics();
      var width = context.getWidth();
      this.minTotalWidth += width;
      var min_x = 0;
      var pixels_used = width;

      // Calculate space between last note and next note.
      tick_space = Math.min((tick - prev_tick) * this.pixelsPerTick, pixels_used);

      // Shift next note up `tick_space` pixels.
      var set_x = x + tick_space;

      // Calculate the minimum next note position to allow for right modifiers.
      if (lastMetrics != null) {
        min_x = x + prev_width - lastMetrics.extraLeftPx;
      }

      // Determine the space required for the previous tick.
      // The `shouldIgnoreTicks` bool is true for elements in the stave
      // that don't consume ticks (bar lines, key and time signatures, etc.)
      set_x = context.shouldIgnoreTicks() ?
              (min_x + context.getWidth()) : Math.max(set_x, min_x);

      if (context.shouldIgnoreTicks() && justifyWidth) {
        // This note stole room... recalculate with new justification width.
        justifyWidth -= context.getWidth();
        this.pixelsPerTick = justifyWidth /
                             (this.totalTicks.value() * contexts.resolutionMultiplier);
      }

      // Determine pixels needed for left modifiers.
      var left_px = thisMetrics.extraLeftPx;

      // Determine white space to right of previous tick (from right modifiers.)
      if (lastMetrics != null) {
        white_space = (set_x - x) - (prev_width -
                                     lastMetrics.extraLeftPx);
      }

      // Deduct pixels from white space quota.
      if (i > 0) {
        if (white_space > 0) {
          if (white_space >= left_px) {
            // Have enough white space for left modifiers - no offset needed.
            left_px = 0;
          } else {
            // Decrease left modifier offset by amount of white space.
            left_px -= white_space;
          }
        }
      }

      // Adjust the tick x position with the left modifier offset.
      set_x += left_px;

      // Set the `x` value for the context, which sets the `x` value for all
      // tickables in this context.
      context.setX(set_x);
      context.setPixelsUsed(pixels_used);  // ??? Remove this if nothing breaks

      lastMetrics = thisMetrics;
      prev_width = width;
      prev_tick = tick;
      x = set_x;
    }

    this.hasMinTotalWidth = true;
    if (justifyWidth > 0) {
      // Pass 2: Take leftover width, and distribute it to proportionately to
      // all notes.
      var remaining_x = initial_justify_width - (x + prev_width);
      var leftover_pixels_per_tick = remaining_x / (this.totalTicks.value() * contexts.resolutionMultiplier);
      var accumulated_space = 0;
      prev_tick = 0;

      for (i = 0; i < contextList.length; ++i) {
        tick = contextList[i];
        context = contextMap[tick];
        tick_space = (tick - prev_tick) * leftover_pixels_per_tick;
        accumulated_space = accumulated_space + tick_space;
        context.setX(context.getX() + accumulated_space);
        prev_tick = tick;

        // ### START ADDITION
        // Move center aligned tickables to middle
        var centeredTickables = context.getCenterAlignedTickables();
        centeredTickables.forEach(function(tickable) {
          // tickable.x_shift = center_x - context.getX();
          tickable.x_shift = (justifyWidth - tickable.getWidth()) / 2;
        });
        // ### END ADDITION
      }
    }
  };





  window.MSV = {
    Viewer : Viewer,
    Logger : Logger,
    AbstractAreaCollection : AbstractAreaCollection,
    DefaultAreaCollection : DefaultAreaCollection,
    Util : MEI2VF.Util
  };


